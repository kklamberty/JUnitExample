import java.util.Random;

public final class LinkedListBag<T> implements bagDataStructure<T> {

    /* The data fields and helper methods needed for the methods in the interface*/

    private Node firstNode; //head reference, tells where the first node is
    private int numberOfEntries; //records number of entries in a given bag
    public LinkedListBag()
    {
        /* initially a bag is empty, so firstNode is set to null and numberOfEntries is 0*/
        firstNode = null;
        numberOfEntries = 0;
    }
    private class Node
    {
        /* an inner class since it's within the class LinkedListBag,
        the getter and setter methods grab the data and reference to the next node
         */
        private T data; //entry (object) in a bag
        private Node next; //link to next node
        private T getData(){ return data; }
        private void setData(T newData) { data = newData;}
        private Node getNextNode() { return next; }
        private void setNextNode(Node nextNode){ next = nextNode;}

        /* there are two constructors for the node because there is one to tell what the data is another to reference the next node*/


        private Node(T dataPortion) //constructor
        {
            this(dataPortion,null);
        }
        private Node(T dataPortion,Node nextNode) { //creates the node and its components
            data = dataPortion; //data/object
            next = nextNode; //reference to the next node
        }
    }
    private Node getReferenceTo(T anEntry)
    {
        boolean found = false;
        Node currentNode = firstNode;
        while (!found && (currentNode != null))
        {
            if (anEntry.equals(currentNode.data))
                found = true;
            else
                currentNode = currentNode.getNextNode();
        }
        return currentNode;
    }




    /* The methods implemented from the interface*/

    public int getCurrentSize() //returns the number of entries in the linked list
    {
        return numberOfEntries;
    }
    public boolean isEmpty() //true or false whether or not the linked list is empty
    {
        return numberOfEntries == 0;
    }
    public boolean add(T newEntry)
    {
        //adding to beginning of the chain
        Node newNode = new Node(newEntry);
        newNode.setNextNode(firstNode); //Make the current node reference the next node
        //firstNode is null if the chain is empty

        firstNode = newNode; //Make the next referenced node be called newNode
        numberOfEntries++;
        return true;
    }

    /* result is first set to null in case the list is empty. I used int random and Math.random()
    after importing java.util.random from the Java library. This generated a random number
    since it was multiplied by numberOfEntries. So I found a random spot in the list. The for
    loop found where this spot was located by making firstNode = startNode and using next to cycle through
    the list to find the spot generated by random. Once the spot was found the for loop terminated and
    startNode was given the data and reference of the removed node. Then I decremented the number
    of entries */
    public T removeRandom() { //removes a random node from the list
        T result = null;
        int random = (int)(Math.random()*numberOfEntries);
        int i = 0;
        Node startNode = firstNode;
        for (i = 0; i< random;i++){
            startNode = startNode.next;
        }
        result = startNode.data;
        startNode = startNode.next;

        numberOfEntries--;
        return result;
    }
    public boolean removeSpecific(T anEntry) //removes a specified node from the list which is input from the client
    {
        boolean result = false;
        Node nodeN = getReferenceTo(anEntry);
        if (nodeN != null)
        {
            nodeN.setData(firstNode.getData());
            firstNode = firstNode.next;
            numberOfEntries--;
            result = true;
        }
        return result;
    }
    public void clear() //removes all entries from the array and doesn't have a return value
    {
        firstNode = null;
        /* Reset the number of entries equal to 0 because even though
        the nodes are cleared of all data, the nodes themselves still exist. They're
        like something to hold the data and references*/
        numberOfEntries = 0;
    }
    public int getFrequencyOf(T anEntry) //tells the frequency in an array of a user input
    {
        int frequency = 0;
        int loopCounter = 0;
        Node currentNode = firstNode;
        while ((loopCounter < numberOfEntries) && (currentNode != null))
        {
            if (anEntry.equals(currentNode.data))
                frequency++;
            loopCounter++;
            currentNode = currentNode.next;
        }
        return frequency;
    }
    public boolean contains(T anEntry) //tells whether or not a user input entry is contained within the list
    {
        boolean found = false;
        Node currentNode = firstNode;
        while (!found && (currentNode != null))
        {
            if (anEntry.equals(currentNode.data))
                found = true;
            else
                currentNode = currentNode.next;
        }
        return found;
    }
    public T[] toArray() //assists the add method in seeing all of the bag's contents
    {
        T[] result = (T[])new Object[numberOfEntries];
        int index = numberOfEntries - 1;
        Node currentNode = firstNode;
        while ((index < numberOfEntries) && (currentNode != null))
        {
            System.out.println("The number of entries equals = " + numberOfEntries);
            result[index] = currentNode.data;
            System.out.println("The data in index [" + index + "] is " + result[index]);
            index--;
            currentNode = currentNode.next;
        }
        return result;
    }


}


